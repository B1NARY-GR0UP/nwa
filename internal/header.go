// Copyright 2023 BINARY Members
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file may have been modified by BINARY Members. All BINARY
// Modifications are Copyright 2023 BINARY Members.

package internal

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"path/filepath"
	"regexp"
	"slices"
	"strings"
	"unicode"
)

var errUnsupportedFileType = errors.New("file type not supported, header generated failed")

var utf8BOM = []byte{0xEF, 0xBB, 0xBF}

var (
	// k: extension
	// v: header
	cache   = make(map[string][]byte)
	extMaps = []struct {
		top  string
		mid  string
		bot  string
		exts []string
	}{
		{
			top:  "/*",
			mid:  " * ",
			bot:  " */",
			exts: []string{".c", ".h", ".gv", ".java", ".scala", ".kt", ".kts", ".php", ".thrift"},
		},
		{
			top:  "/**",
			mid:  " * ",
			bot:  " */",
			exts: []string{".js", ".mjs", ".cjs", ".jsx", ".tsx", ".css", ".scss", ".sass", ".ts", ".cts", ".mts"},
		},
		{
			top:  "",
			mid:  "// ",
			bot:  "",
			exts: []string{".cc", ".cpp", ".cs", ".go", ".hcl", ".hh", ".hpp", ".m", ".mm", ".proto", ".rs", ".swift", ".dart", ".groovy", ".v", ".sv"},
		},
		{
			top:  "",
			mid:  "# ",
			bot:  "",
			exts: []string{".py", ".sh", ".yaml", ".yml", "makefile", ".mk", "containerfile", ".dockerfile", "dockerfile", ".rb", "gemfile", ".tcl", ".tf", ".bzl", ".pl", ".pp", "build", ".build", ".toml", ".nix", ".ps1", ".psm1"},
		},
		{
			top:  "",
			mid:  ";; ",
			bot:  "",
			exts: []string{".el", ".lisp"},
		},
		{
			top:  "",
			mid:  "% ",
			bot:  "",
			exts: []string{".erl"},
		},
		{
			top:  "",
			mid:  "-- ",
			bot:  "",
			exts: []string{".hs", ".sql", ".sdl", ".lua"},
		},
		{
			top:  "<!--",
			mid:  " ",
			bot:  "-->",
			exts: []string{".html", ".markdown", ".md", ".xml", ".vue", ".wxi", ".wxl", ".wxs"},
		},
		{
			top:  "{#",
			mid:  "",
			bot:  "#}",
			exts: []string{".j2", ".twig"},
		},
		{
			top:  "(**",
			mid:  "   ",
			bot:  "*)",
			exts: []string{".ml", ".mli", ".mll", ".mly"},
		},
		{
			top:  "",
			mid:  `" `,
			bot:  "",
			exts: []string{".vim"},
		},
	}
)

func generateHeader(path string, tmpl []byte) ([]byte, error) {
	var header []byte

	base := strings.ToLower(filepath.Base(path))
	ext := base
	// use file name if there is no extension
	if e := filepath.Ext(base); e != "" {
		ext = e
	}

	// return cache if the header is generated by the file with same extension
	if h, ok := cache[ext]; ok {
		return h, nil
	}

	for _, extMap := range extMaps {
		if slices.Contains(extMap.exts, ext) {
			header = doGenerate(tmpl, extMap.top, extMap.mid, extMap.bot)
			// cache generated header
			cache[ext] = header
			return header, nil
		}
	}

	if base == "cmakelists.txt" || strings.HasSuffix(base, ".cmake.in") || strings.HasSuffix(base, ".cmake") {
		header = doGenerate(tmpl, "", "# ", "")
		return header, nil
	}

	return nil, errUnsupportedFileType
}

func doGenerate(tmpl []byte, top, mid, bot string) []byte {
	t := bytes.NewBuffer(tmpl)
	buf := bytes.NewBuffer(nil)
	if top != "" {
		_, _ = fmt.Fprintln(buf, top)
	}
	s := bufio.NewScanner(t)
	for s.Scan() {
		_, _ = fmt.Fprintln(buf, strings.TrimRightFunc(mid+s.Text(), unicode.IsSpace))
	}
	if bot != "" {
		_, _ = fmt.Fprintln(buf, bot)
	}
	return buf.Bytes()
}

func isGenerated(b []byte) bool {
	// go generate: ^// Code generated .* DO NOT EDIT\.$
	goGenerated := regexp.MustCompile(`(?m)^.{1,2} Code generated .* DO NOT EDIT\.$`)
	// cargo raze: ^DO NOT EDIT! Replaced on runs of cargo-raze$
	cargoRazeGenerated := regexp.MustCompile(`(?m)^DO NOT EDIT! Replaced on runs of cargo-raze$`)
	return goGenerated.Match(b) || cargoRazeGenerated.Match(b)
}

func hasHeader(b []byte, keywords []string) bool {
	n := 1000
	if len(b) < n {
		n = len(b)
	}

	lowerHeader := bytes.ToLower(b[:n])

	if len(keywords) != 0 {
		for _, keyword := range keywords {
			lowerKeyword := bytes.ToLower([]byte(keyword))
			if bytes.Contains(lowerHeader, lowerKeyword) {
				return true
			}
		}
		return false
	}

	return bytes.Contains(lowerHeader, []byte("copyright")) ||
		bytes.Contains(lowerHeader, []byte("Â©")) ||
		bytes.Contains(lowerHeader, []byte("copr.")) ||
		bytes.Contains(lowerHeader, []byte("mozilla public")) ||
		bytes.Contains(lowerHeader, []byte("spdx-license-identifier"))
}

func matchShebang(b []byte) []byte {
	var line []byte
	fls := []string{
		"#!",                       // shell script
		"<?xml",                    // XML declaration
		"<!doctype",                // HTML doctype
		"# encoding:",              // Ruby encoding
		"# frozen_string_literal:", // Ruby interpreter instruction
		"<?php",                    // PHP opening tag
		"# escape",                 // Dockerfile directive https://docs.docker.com/engine/reference/builder/#parser-directives
		"# syntax",                 // Dockerfile directive https://docs.docker.com/engine/reference/builder/#parser-directives
	}
	// get headline of the file
	for _, c := range b {
		line = append(line, c)
		if c == '\n' {
			break
		}
	}
	first := strings.ToLower(string(line))
	// match first line
	for _, fl := range fls {
		if strings.HasPrefix(first, fl) {
			return line
		}
	}
	return nil
}

// check for UTF-8 BOM at the start of content
func matchBOM(content []byte) bool {
	return len(content) >= 3 && bytes.Equal(content[:3], utf8BOM)
}

func assemble(shebang, header, content []byte, hasBOM, isUpdate bool) []byte {
	var body []byte

	if hasBOM {
		body = append(body, utf8BOM...)
		// content of update does not contain a BOM
		if !isUpdate {
			content = content[3:]
		}
	}

	if shebang != nil {
		// NOTE:
		// add - content is the complete file;
		// update - content is the content after the first blank line;
		// so if we use add, we need to extract shebang first to avoid inserting shebang twice
		if !isUpdate {
			// get content exclude the shebang
			content = content[len(shebang):]
		}

		// add \n if the shebang do not end with \n
		if shebang[len(shebang)-1] != '\n' {
			shebang = append(shebang, '\n')
		}

		// this is the header included shebang
		header = append(shebang, header...)
	}

	// 1. BOM (if present)
	// 2. shebang (if present)
	// 3. header
	// 4. content
	body = append(body, header...)
	body = append(body, content...)
	return body
}
