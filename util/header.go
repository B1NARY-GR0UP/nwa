// Copyright 2023 BINARY Members
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file may have been modified by BINARY Members. All BINARY
// Modifications are Copyright 2023 BINARY Members.

package util

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"path/filepath"
	"regexp"
	"strings"
	"unicode"
)

var errUnsupportedFileType = errors.New("file type not supported, header generated failed")

var cache = make(map[string][]byte)

func put(header []byte, exts []string) {
	for _, ext := range exts {
		cache[ext] = header
	}
}

func generateHeader(path string, tmpl []byte) ([]byte, error) {
	var header []byte
	base := strings.ToLower(filepath.Base(path))
	ext := base
	// use file name if there is no extension
	if e := filepath.Ext(base); e != "" {
		ext = e
	}
	// return cache if the header is generated by the file with same extension
	if h, ok := cache[ext]; ok {
		return h, nil
	}
	switch ext {
	case ".c", ".h", ".gv", ".java", ".scala", ".kt", ".kts", ".php":
		header = doGenerate(tmpl, "/*", " * ", " */")
		put(header, []string{".c", ".h", ".gv", ".java", ".scala", ".kt", ".kts", ".php"})
	case ".js", ".mjs", ".cjs", ".jsx", ".tsx", ".css", ".scss", ".sass", ".ts":
		header = doGenerate(tmpl, "/**", " * ", " */")
		put(header, []string{".js", ".mjs", ".cjs", ".jsx", ".tsx", ".css", ".scss", ".sass", ".ts"})
	case ".cc", ".cpp", ".cs", ".go", ".hcl", ".hh", ".hpp", ".m", ".mm", ".proto", ".rs", ".swift", ".dart", ".groovy", ".v", ".sv":
		header = doGenerate(tmpl, "", "// ", "")
		put(header, []string{".cc", ".cpp", ".cs", ".go", ".hcl", ".hh", ".hpp", ".m", ".mm", ".proto", ".rs", ".swift", ".dart", ".groovy", ".v", ".sv"})
	case ".py", ".sh", ".yaml", ".yml", ".dockerfile", "dockerfile", ".rb", "gemfile", ".tcl", ".tf", ".bzl", ".pl", ".pp", "build", ".build", ".toml":
		header = doGenerate(tmpl, "", "# ", "")
		put(header, []string{".py", ".sh", ".yaml", ".yml", ".dockerfile", "dockerfile", ".rb", "gemfile", ".tcl", ".tf", ".bzl", ".pl", ".pp", "build", ".build", ".toml"})
	case ".el", ".lisp":
		header = doGenerate(tmpl, "", ";; ", "")
		put(header, []string{".el", ".lisp"})
	case ".erl":
		header = doGenerate(tmpl, "", "% ", "")
		put(header, []string{".erl"})
	case ".hs", ".sql", ".sdl":
		header = doGenerate(tmpl, "", "-- ", "")
		put(header, []string{".hs", ".sql", ".sdl"})
	case ".html", ".xml", ".vue", ".wxi", ".wxl", ".wxs":
		header = doGenerate(tmpl, "<!--", " ", "-->")
		put(header, []string{".html", ".xml", ".vue", ".wxi", ".wxl", ".wxs"})
	case ".j2", ".twig":
		header = doGenerate(tmpl, "{#", "", "#}")
		put(header, []string{".j2", ".twig"})
	case ".ml", ".mli", ".mll", ".mly":
		header = doGenerate(tmpl, "(**", "   ", "*)")
		put(header, []string{".ml", ".mli", ".mll", ".mly"})
	default:
		if base == "cmakelists.txt" || strings.HasSuffix(base, ".cmake.in") || strings.HasSuffix(base, ".cmake") {
			header = doGenerate(tmpl, "", "# ", "")
		} else {
			return nil, errUnsupportedFileType
		}
	}
	return header, nil
}

func doGenerate(tmpl []byte, top, mid, bot string) []byte {
	// TODO: optimize use deep copy?
	t := bytes.NewBuffer(tmpl)
	buf := bytes.NewBuffer(nil)
	if top != "" {
		_, _ = fmt.Fprintln(buf, top)
	}
	s := bufio.NewScanner(t)
	for s.Scan() {
		_, _ = fmt.Fprintln(buf, strings.TrimRightFunc(mid+s.Text(), unicode.IsSpace))
	}
	if bot != "" {
		_, _ = fmt.Fprintln(buf, bot)
	}
	// add blank line at the end
	_, _ = fmt.Fprintln(buf)
	return buf.Bytes()
}

func isGenerated(b []byte) bool {
	// go generate: ^// Code generated .* DO NOT EDIT\.$
	goGenerated := regexp.MustCompile(`(?m)^.{1,2} Code generated .* DO NOT EDIT\.$`)
	// cargo raze: ^DO NOT EDIT! Replaced on runs of cargo-raze$
	cargoRazeGenerated := regexp.MustCompile(`(?m)^DO NOT EDIT! Replaced on runs of cargo-raze$`)
	return goGenerated.Match(b) || cargoRazeGenerated.Match(b)
}

func hasHeader(b []byte) bool {
	n := 1000
	if len(b) < n {
		n = len(b)
	}
	return bytes.Contains(bytes.ToLower(b[:n]), []byte("copyright")) ||
		bytes.Contains(bytes.ToLower(b[:n]), []byte("mozilla public")) ||
		bytes.Contains(bytes.ToLower(b[:n]), []byte("spdx-license-identifier"))
}

func matchShebang(b []byte) []byte {
	var line []byte
	fls := []string{
		"#!",                       // shell script
		"<?xml",                    // XML declaratioon
		"<!doctype",                // HTML doctype
		"# encoding:",              // Ruby encoding
		"# frozen_string_literal:", // Ruby interpreter instruction
		"<?php",                    // PHP opening tag
		"# escape",                 // Dockerfile directive https://docs.docker.com/engine/reference/builder/#parser-directives
		"# syntax",                 // Dockerfile directive https://docs.docker.com/engine/reference/builder/#parser-directives
	}
	// get headline of the file
	for _, c := range b {
		line = append(line, c)
		if c == '\n' {
			break
		}
	}
	first := strings.ToLower(string(line))
	// match first line
	for _, fl := range fls {
		if strings.HasPrefix(first, fl) {
			return line
		}
	}
	return nil
}

func assemble(line, header, content []byte, isUpdate bool) []byte {
	if line != nil {
		// line, content
		// get content exclude the first line
		if !isUpdate {
			content = content[len(line):]
		}
		// add \n if the first line do not end with \n
		if line[len(line)-1] != '\n' {
			line = append(line, '\n')
		}
		header = append(line, header...)
	}
	// line, header, content
	header = append(header, content...)
	return header
}
